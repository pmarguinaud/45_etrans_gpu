PROGRAM TEST_ADJOINT
USE PARKIND1  ,ONLY : JPIM     ,JPRB
USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK

USE MPL_MODULE  ,ONLY : MPL_ALLREDUCE, MPL_INIT, MPL_END, MPL_BARRIER, &
     &                  MPL_BUFFER_METHOD, MPL_MYRANK
! This is not really correct usage
USE ABORT_TRANS_MOD ,ONLY : ABORT_TRANS

IMPLICIT NONE

INTEGER(KIND=JPIM) :: I_NSMAX,NDGL,I_NPROC,NPRGPNS,NPRGPEW,NPRTRW,NPRTRV,NREP
INTEGER(KIND=JPIM) :: I_NMSMAX, I_NDLON, I_NDGUX, J
INTEGER(KIND=JPIM) , ALLOCATABLE :: ISNAX(:),ISMAX(:)
INTEGER(KIND=JPIM) :: I_NOUT,I_MYPROC,I_NSPECG,I_NSPEC2G,I_NGPTOTG
INTEGER(KIND=JPIM) :: I_NFLEV,NFLEVG,NSEED
INTEGER(KIND=JPIM) :: I_NSPEC2,I_NGPTOT,NPROMA,I_NGPBLKS,I_MYSETV,I_NUMP
INTEGER(KIND=JPIM) ,ALLOCATABLE :: I_NLOEN(:),ITO(:),I_MYMS(:)
INTEGER(KIND=JPIM) ,ALLOCATABLE :: I_NESM0(:),I_NCPL2M(:),I_SEED(:),IVSET(:)
INTEGER(KIND=JPIM) :: JLEV,JREP

CHARACTER (LEN = 6) ::  CLNAME

LOGICAL :: LMPOFF

REAL(KIND=JPRB) , ALLOCATABLE :: ZSPECX(:,:),ZSPECY(:,:),ZSPECP(:,:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZVORX(:,:),ZVORY(:,:),ZVORP(:,:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZDIVX(:,:),ZDIVY(:,:),ZDIVP(:,:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZGX(:,:,:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZSPECYG(:,:),ZSPECXG(:,:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZVORYG(:,:),ZVORXG(:,:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZDIVYG(:,:),ZDIVXG(:,:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZRANDSP(:),ZRANDGP(:,:),ZPERT(:,:,:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZMEANUX(:), ZMEANVX(:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZMEANUY(:), ZMEANVY(:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZMEANUP(:), ZMEANVP(:)
REAL(KIND=JPRB) :: ZSC, ZSCUV, ZSCT
REAL(KIND=JPRB) :: Z_EXWN, Z_EYWN
REAL(KIND=JPRB) :: ZHOOK_HANDLE

NAMELIST /NAMCTL/ NPROMA,NPRGPNS,NPRGPEW,NPRTRW,NPRTRV,NREP,NDGL,NFLEVG,LMPOFF

#include "setup_trans0.h"
#include "esetup_trans.h"
#include "etrans_inq.h"
#include "edir_trans.h"
#include "einv_trans.h"
#include "edir_transad.h"
#include "einv_transad.h"
#include "edist_grid.h"
#include "edist_spec.h"

IF (LHOOK) CALL DR_HOOK('TEST_ADJOINT',0,ZHOOK_HANDLE)

I_NSMAX=47
NDGL=144
NPROMA=8
I_NMSMAX=66
I_NDLON=200
I_NDGUX=133
NFLEVG=31
LMPOFF=.FALSE.

ALLOCATE(ISNAX(0:I_NMSMAX))
ALLOCATE(ISMAX(0:I_NSMAX))
ALLOCATE(I_NESM0(0:I_NMSMAX))
ALLOCATE(I_NCPL2M(0:I_NMSMAX))
CALL ELLIPS(I_NSMAX,I_NMSMAX,ISNAX,ISMAX)
WRITE(I_NOUT,*) ' I_NSMAX= ',I_NSMAX

I_NSPECG=0
DO J=0,I_NMSMAX
  I_NSPECG=I_NSPECG+2*(ISNAX(J)+1)
ENDDO
WRITE(*,*) 'I_NSPECG:', I_NSPECG
I_NSPEC2G=I_NSPECG*2

NPRGPNS = 5
NPRGPEW = 1
NPRTRW = 5
NPRTRV = 1
NREP=1

READ(4,NAMCTL)
I_NPROC = NPRGPNS*NPRGPEW
IF(I_NPROC /= NPRTRW*NPRTRV) THEN
  PRINT *,'NPRGPNS,NPRGPEW,NPRTRW,NPRTRV ',NPRGPNS,NPRGPEW,NPRTRW,NPRTRV
  CALL ABORT_TRANS('NPRGPNS*NPRGPEW /= NPRTRW*NPRTRV')
ENDIF
WRITE(I_NOUT,*) ' NDGL=',NDGL

IF(I_NPROC > 1 .OR..NOT.LMPOFF) THEN
  CALL MPL_INIT
  I_MYPROC = MPL_MYRANK()
  I_NOUT = 20
  WRITE(CLNAME,'(A,I2.2)') 'OUT.',I_MYPROC
  OPEN(I_NOUT,FILE=CLNAME)
  CALL MPL_BUFFER_METHOD(KMP_TYPE=2,KMBX_SIZE=64000000,&
   & KPROCIDS=(/ (J, J=1,I_NPROC) /))
ELSE
  I_NOUT = 6
  I_MYPROC = 1
ENDIF
I_MYSETV = MOD(I_MYPROC-1,NPRTRV)+1

! Allocate global arrays.

ALLOCATE(ZSPECYG(NFLEVG,I_NSPEC2G))
ALLOCATE(ZSPECXG(NFLEVG,I_NSPEC2G))
ALLOCATE(ZVORYG(NFLEVG,I_NSPEC2G))
ALLOCATE(ZVORXG(NFLEVG,I_NSPEC2G))
ALLOCATE(ZDIVYG(NFLEVG,I_NSPEC2G))
ALLOCATE(ZDIVXG(NFLEVG,I_NSPEC2G))
ALLOCATE(ZRANDSP(I_NSPEC2G))
ALLOCATE(I_NLOEN(NDGL))
ALLOCATE(ITO(NFLEVG))
ALLOCATE(IVSET(NFLEVG))

I_NFLEV = 0
DO JLEV=1,NFLEVG
  IVSET(JLEV) = MOD(JLEV,NPRTRV)+1
  IF(IVSET(JLEV) == I_MYSETV) I_NFLEV = I_NFLEV+1
ENDDO
WRITE(I_NOUT,*)' I_NFLEV=',I_NFLEV,' IVSET=',IVSET

I_NLOEN(:) = I_NDLON
CALL SETUP_TRANS0(KOUT=I_NOUT,KERR=0,KPRINTLEV=2,KMAX_RESOL=1,&
 & KPRGPNS=NPRGPNS,KPRGPEW=NPRGPEW,KPRTRW=NPRTRW)

Z_EXWN=0.3926377E-05
Z_EYWN=0.5453301E-05
CALL ESETUP_TRANS(KMSMAX=I_NMSMAX,KSMAX=I_NSMAX,KDGL=NDGL,KDGUX=I_NDGUX, &
 & KLOEN=I_NLOEN,LDSPLIT=.FALSE.,PEXWN=Z_EXWN, PEYWN=Z_EYWN)

CALL ETRANS_INQ(KSPEC2=I_NSPEC2,KGPTOT=I_NGPTOT,KGPTOTG=I_NGPTOTG,KNUMP=I_NUMP)
I_NGPBLKS = (I_NGPTOT-1)/NPROMA+1
WRITE(I_NOUT,*) 'I_NSPEC2=',I_NSPEC2,' I_NGPTOT=',I_NGPTOT,' I_NGPBLKS=',I_NGPBLKS

ALLOCATE(I_MYMS(I_NUMP))
ALLOCATE(ZRANDGP(I_NGPTOTG,1))

CALL ETRANS_INQ(KMYMS=I_MYMS,KESM0=I_NESM0,KCPL2M=I_NCPL2M)
WRITE(I_NOUT,*) 'I_MYMS=',I_MYMS,' I_NESM0=',I_NESM0,' I_NCPL2M=',I_NCPL2M

WRITE(I_NOUT,*) 'SETUP FINISHED'
CALL FLUSH(I_NOUT)

! Allocate local arrays.

ALLOCATE(ZSPECX(I_NFLEV,I_NSPEC2))
ALLOCATE(ZSPECY(I_NFLEV,I_NSPEC2))
ALLOCATE(ZSPECP(I_NFLEV,I_NSPEC2))
ALLOCATE(ZVORX(I_NFLEV,I_NSPEC2))
ALLOCATE(ZVORY(I_NFLEV,I_NSPEC2))
ALLOCATE(ZVORP(I_NFLEV,I_NSPEC2))
ALLOCATE(ZDIVX(I_NFLEV,I_NSPEC2))
ALLOCATE(ZDIVY(I_NFLEV,I_NSPEC2))
ALLOCATE(ZDIVP(I_NFLEV,I_NSPEC2))
ALLOCATE(ZMEANUX(I_NFLEV))
ALLOCATE(ZMEANVX(I_NFLEV))
ALLOCATE(ZMEANUY(I_NFLEV))
ALLOCATE(ZMEANVY(I_NFLEV))
ALLOCATE(ZMEANUP(I_NFLEV))
ALLOCATE(ZMEANVP(I_NFLEV))
ALLOCATE(ZGX(NPROMA,3*NFLEVG,I_NGPBLKS))
ALLOCATE(ZPERT(NPROMA,1,I_NGPBLKS))

! Get seed of random number generator

CALL RANDOM_SEED(SIZE=NSEED)
ALLOCATE(I_SEED(NSEED))
CALL RANDOM_SEED(GET=I_SEED)

! Prepare perturbations

IF(I_MYPROC == 1) THEN
  DO JLEV=1,NFLEVG
    CALL RANDOM_NUMBER(ZRANDSP)
    ZSPECYG(JLEV,:) = (1.0_JPRB-2.0_JPRB*ZRANDSP(:))
    CALL RANDOM_NUMBER(ZRANDSP)
    ZSPECXG(JLEV,:) = (1.0_JPRB-2.0_JPRB*ZRANDSP(:))
    CALL RANDOM_NUMBER(ZRANDSP)
    ZVORYG(JLEV,:) = (1.0_JPRB-2.0_JPRB*ZRANDSP(:))
    CALL RANDOM_NUMBER(ZRANDSP)
    ZVORXG(JLEV,:) = (1.0_JPRB-2.0_JPRB*ZRANDSP(:))
    CALL RANDOM_NUMBER(ZRANDSP)
    ZDIVYG(JLEV,:) = (1.0_JPRB-2.0_JPRB*ZRANDSP(:))
    CALL RANDOM_NUMBER(ZRANDSP)
    ZDIVXG(JLEV,:) = (1.0_JPRB-2.0_JPRB*ZRANDSP(:))
  ENDDO
  CALL RANDOM_NUMBER(ZRANDGP)
  ZRANDGP(:,:) = (1.0_JPRB-2.0_JPRB*ZRANDGP(:,:))
ENDIF

ITO(:) = 1
ZSPECX = 0.0_JPRB
ZSPECY = 0.0_JPRB
ZSPECP = 0.0_JPRB
ZVORX  = 0.0_JPRB
ZVORY  = 0.0_JPRB
ZVORP  = 0.0_JPRB
ZDIVX  = 0.0_JPRB
ZDIVY  = 0.0_JPRB
ZDIVP  = 0.0_JPRB
ZMEANUP= 0.0_JPRB
ZMEANVP= 0.0_JPRB
ZGX    = 0.0_JPRB

! Reset the random number generator, so that all threads
! get the same numbers for ZMEAN{U|V}{X|Y}.

CALL RANDOM_SEED(PUT=I_SEED)

CALL RANDOM_NUMBER(ZMEANUX)
CALL RANDOM_NUMBER(ZMEANVX)
CALL RANDOM_NUMBER(ZMEANUY)
CALL RANDOM_NUMBER(ZMEANVY)

! Distribute perturbations

CALL EDIST_GRID(PGPG=ZRANDGP,KFDISTG=1,KFROM=ITO,PGP=ZPERT,KPROMA=NPROMA)
CALL EDIST_SPEC(PSPECG=ZSPECXG,KFDISTG=NFLEVG,KFROM=ITO,PSPEC=ZSPECX,&
 & KVSET=IVSET)
CALL EDIST_SPEC(PSPECG=ZVORXG,KFDISTG=NFLEVG,KFROM=ITO,PSPEC=ZVORX,&
 & KVSET=IVSET)
CALL EDIST_SPEC(PSPECG=ZDIVXG,KFDISTG=NFLEVG,KFROM=ITO,PSPEC=ZDIVX,&
 & KVSET=IVSET)

DO JREP=1,NREP

  CALL EDIST_SPEC(PSPECG=ZSPECYG,KFDISTG=NFLEVG,KFROM=ITO,PSPEC=ZSPECY,&
   & KVSET=IVSET)
  CALL EDIST_SPEC(PSPECG=ZVORYG,KFDISTG=NFLEVG,KFROM=ITO,PSPEC=ZVORY,&
   & KVSET=IVSET)
  CALL EDIST_SPEC(PSPECG=ZDIVYG,KFDISTG=NFLEVG,KFROM=ITO,PSPEC=ZDIVY,&
   & KVSET=IVSET)

! Direct calculations

  IF (JREP == NREP) THEN
    WRITE(I_NOUT,*) 'DIRECT ELOTT ZMEANUX:', ZMEANUX
    WRITE(I_NOUT,*) 'DIRECT ELOTT ZMEANVX:', ZMEANVX
  ENDIF

  CALL EINV_TRANS(PSPVOR=ZVORX,PSPDIV=ZDIVX,PSPSCALAR=ZSPECX,PGP=ZGX,&
   & PMEANU=ZMEANUX,PMEANV=ZMEANVX, KPROMA=NPROMA, KVSETSC=IVSET,&
   & KVSETUV=IVSET)
  CALL GPC(ZGX)
  CALL EDIR_TRANS(PSPSCALAR=ZSPECP,PSPVOR=ZVORP,PSPDIV=ZDIVP,PGP=ZGX,&
   & KPROMA=NPROMA,KVSETSC=IVSET, KVSETUV=IVSET,&
   & PMEANU=ZMEANUP,PMEANV=ZMEANVP)

  ZSC=SCALPRODSP(ZSPECP,ZSPECY)+SCALPRODSP(ZVORP,ZVORY)+SCALPRODSP(ZDIVP,ZDIVY)

! Gather ZSC

  IF (I_NPROC > 1) CALL MPL_ALLREDUCE(ZSC,'SUM',.TRUE.)

  ZSCUV=SUM(ZMEANUP*ZMEANUY+ZMEANVP*ZMEANVY)

! Gather ZSCUV.  Note: In case of b-parallellization, the answer
! gathered is based on NPRTRW groups of NPRTRV processors working
! on that calculation, so the answer is NPRTRW times too large.

  IF (I_NPROC > 1) CALL MPL_ALLREDUCE(ZSCUV,'SUM',.TRUE.)
  ZSCUV=ZSCUV/NPRTRW

  ZSCT=ZSC+ZSCUV
  IF(JREP == NREP) WRITE(I_NOUT,*)'FINAL <Fx,y> ',ZSCT

! Adjoint calculations

  ZSPECP = 0.0_JPRB
  ZVORP  = 0.0_JPRB
  ZDIVP  = 0.0_JPRB
  ZMEANUP= 0.0_JPRB
  ZMEANVP= 0.0_JPRB
  ZGX    = 0.0_JPRB
  CALL EDIR_TRANSAD(PSPSCALAR=ZSPECY,PSPVOR=ZVORY,PSPDIV=ZDIVY,PGP=ZGX,&
   & KPROMA=NPROMA, KVSETSC=IVSET, KVSETUV=IVSET,&
   & PMEANU=ZMEANUY,PMEANV=ZMEANVY)
! The grid point calculation is self-adjoint
!!  CALL GPCAD(ZGX)
  CALL GPC(ZGX)
  CALL EINV_TRANSAD(PSPSCALAR=ZSPECP,PSPVOR=ZVORP,PSPDIV=ZDIVP,PGP=ZGX,&
   & KPROMA=NPROMA,KVSETSC=IVSET,KVSETUV=IVSET,&
   & PMEANU=ZMEANUP,PMEANV=ZMEANVP)

  ZSC=SCALPRODSP(ZSPECX,ZSPECP)+SCALPRODSP(ZVORX,ZVORP)+SCALPRODSP(ZDIVX,ZDIVP)

! Gather ZSC

  IF (I_NPROC > 1) CALL MPL_ALLREDUCE(ZSC,'SUM',.TRUE.)

  ZSCUV=SUM(ZMEANUX*ZMEANUP+ZMEANVX*ZMEANVP)

! Gather ZSCUV.  Note: In case of b-parallellization, the answer
! gathered is based on NPRTRW groups of NPRTRV processors working
! on that calculation, so the answer is NPRTRW times too large.

  IF (I_NPROC > 1) CALL MPL_ALLREDUCE(ZSCUV,'SUM',.TRUE.)
  ZSCUV=ZSCUV/NPRTRW

  ZSCT=ZSC+ZSCUV
  IF(JREP == NREP) WRITE(I_NOUT,*)'FINAL <x,F*y> ',ZSCT

ENDDO

IF(I_NPROC > 1 .OR..NOT.LMPOFF) THEN
  CALL MPL_BARRIER()
  CALL MPL_END
ENDIF

IF (LHOOK) CALL DR_HOOK('TEST_ADJOINT',1,ZHOOK_HANDLE)

CONTAINS

SUBROUTINE GPC(PGP)
!
USE PARKIND1  ,ONLY : JPIM,   JPRB
  
IMPLICIT NONE
! Grid-point computations

REAL(KIND=JPRB) :: PGP(:,:,:)

INTEGER(KIND=JPIM) :: JLEV,JKGLO,JROF,IEND,IBL
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('GPC',0,ZHOOK_HANDLE)

DO JLEV=1,3*NFLEVG
  DO JKGLO=1,I_NGPTOT,NPROMA
    IEND = MIN(NPROMA,I_NGPTOT-JKGLO+1)
    IBL  = (JKGLO-1)/NPROMA+1
    DO JROF=1,IEND
      PGP(JROF,JLEV,IBL) = PGP(JROF,JLEV,IBL)*ZPERT(JROF,1,IBL)
    ENDDO
  ENDDO
ENDDO

IF (LHOOK) CALL DR_HOOK('GPC',1,ZHOOK_HANDLE)

END SUBROUTINE GPC

REAL(KIND=JPRB) FUNCTION SCALPRODSP(PSP1,PSP2)

! Scalar product in spectral space
!
USE PARKIND1  ,ONLY : JPIM,   JPRB

IMPLICIT NONE

REAL(KIND=JPRB) :: PSP1(:,:),PSP2(:,:)

INTEGER(KIND=JPIM) :: JMLOC,IM,JN,INM,JLEV

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('SCALPRODSP',0,ZHOOK_HANDLE)

SCALPRODSP = 0.0_JPRB
DO JLEV=1,I_NFLEV
  DO JMLOC=1,I_NUMP
    IM = I_MYMS(JMLOC)
    DO JN=0,2*I_NCPL2M(IM)-1
      INM=I_NESM0(IM)+JN
      SCALPRODSP = SCALPRODSP + PSP1(JLEV,INM)*PSP2(JLEV,INM)
    ENDDO
  ENDDO
ENDDO

IF (LHOOK) CALL DR_HOOK('SCALPRODSP',1,ZHOOK_HANDLE)

END FUNCTION SCALPRODSP

END PROGRAM TEST_ADJOINT
