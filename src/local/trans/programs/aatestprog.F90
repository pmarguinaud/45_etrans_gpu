PROGRAM TEST

USE MPL_END_MOD, ONLY : MPL_END
USE MPL_INIT_MOD, ONLY : MPL_INIT
USE PARKIND1, ONLY : JPIM, JPRB
USE MPL_MODULE, ONLY : MPL_BARRIER, MPL_MYRANK, MPL_NPROC
USE MPL_DATA_MODULE, ONLY : MPL_COMM_OML
USE YOMHOOK, ONLY : DR_HOOK, LHOOK
USE SET2PE_MOD, ONLY : SET2PE
USE OPENACC

USE XRD_GETOPTIONS

IMPLICIT NONE

REAL (KIND=JPRB), PARAMETER :: RPI = 2._JPRB * ASIN (1.0_JPRB)
REAL (KIND=JPRB), PARAMETER :: DEG2RAD = RPI / 180._JPRB

INTEGER(KIND=JPIM) :: NMSMAX, NSMAX, NDGLG, NPRGPNS, NPRGPEW, NPRTRW, NPRTRV, NDLON, NPRINTLEV, NTIME
INTEGER(KIND=JPIM) :: MYPROC, NPROC, NBSETSP
INTEGER(KIND=JPIM) :: NFLEV
INTEGER(KIND=JPIM) :: NFLEVG
INTEGER(KIND=JPIM) :: NSPEC2, NSPEC2G, NGPTOT, NGPTOTG, MYSETV, MYSETW
INTEGER(KIND=JPIM), ALLOCATABLE :: NLOEN (:) 
INTEGER(KIND=JPIM), ALLOCATABLE :: IFLDSCH (:) 
INTEGER(KIND=JPIM), ALLOCATABLE :: IVSETOFF (:)
INTEGER(KIND=JPIM), POINTER     :: INFD (:), IFLDOFF (:)
INTEGER(KIND=JPIM), ALLOCATABLE, TARGET :: INFD_ALLVSETS (:,:), IFLDOFF_ALLVSETS (:,:)

REAL (KIND=JPRB) :: ZTSTEP, TIMEF

REAL (KIND=JPRB),    ALLOCATABLE :: ZSPBUFL (:,:) 
REAL (KIND=JPRB),    ALLOCATABLE :: ZSPBUFG (:,:) 
REAL (KIND=JPRB),    ALLOCATABLE :: ZGPBUFL (:,:,:) 
REAL (KIND=JPRB),    ALLOCATABLE :: ZGPBUFG (:,:) 
INTEGER (KIND=JPIM), ALLOCATABLE :: NBSETLEV (:) 
INTEGER (KIND=JPIM), ALLOCATABLE :: IVSET (:) 
INTEGER (KIND=JPIM) :: NFLDUA, NFLDSU, IFLD, ILEVG, IGPG, JFLDG1, JFLDG2, IPROC
INTEGER (KIND=JPIM) :: JSETW, JSETV
INTEGER (KIND=JPIM) :: IFLDGPG, IFLDSPL
INTEGER (KIND=JPIM) :: IA, IB
INTEGER (KIND=JPIM) :: NRGRI (8000)
INTEGER (KIND=JPIM) :: ITIME

LOGICAL :: LUSEFLT, LUSERPNM, LKEEPRPNM
LOGICAL :: LSPLIT, LEQ_REGIONS, LDEBUG, LELAM, LLCHECK
LOGICAL :: LLHOOK

#include "setup_trans0.h"

#include "setup_trans.h"
#include "trans_inq.h"
#include "dist_grid.h"
#include "gath_grid.h"
#include "gath_spec.h"
#include "dir_trans.h"
#include "inv_trans.h"

#include "esetup_trans.h"
#include "etrans_inq.h"
#include "edist_grid.h"
#include "egath_grid.h"
#include "egath_spec.h"
#include "edir_trans.h"
#include "einv_trans.h"

#include "abor1.intfb.h"

NAMELIST / NAMAATESTPROG / & 
  & NFLDUA, NFLDSU, NMSMAX, NSMAX, NDGLG, NFLEVG, LDEBUG, NDLON, NPRINTLEV, NTIME, LELAM

NAMELIST / NAMTRANS / & 
  & LUSEFLT, LUSERPNM, LKEEPRPNM

NAMELIST / NAMPAR0 / & 
  & NPRGPNS, NPRGPEW, NPRTRW, NPRTRV

NAMELIST / NAMPAR1 / & 
  & LEQ_REGIONS, LSPLIT

NAMELIST / NAMRGRI / & 
  & NRGRI

CHARACTER (LEN=64) :: CLNAMELIST
CHARACTER (LEN=64) :: CLFIELD
LOGICAL :: LLMPOFF, LLNOWRITE, LLNODIRTRANS, LLNOINVTRANS, LLTESTHARMONICS, LLALLOPERM

REAL (KIND=JPRB) :: ZHOOK_HANDLE


CALL INITOPTIONS ()
CLNAMELIST = 'fort.4'
CALL GETOPTION ("--namelist", CLNAMELIST)
CALL GETOPTION ("--lmpoff", LLMPOFF)
NTIME     = 10
CALL GETOPTION ("--time", NTIME)
CLFIELD = ''
CALL GETOPTION ("--field-file", CLFIELD)
CALL GETOPTION ("--no-write", LLNOWRITE)
CALL GETOPTION ("--no-dir-trans", LLNODIRTRANS)
CALL GETOPTION ("--no-inv-trans", LLNOINVTRANS)
CALL GETOPTION ("--test-harmonics", LLTESTHARMONICS)
CALL GETOPTION ("--alloperm", LLALLOPERM)
CALL GETOPTION ("--check", LLCHECK)
CALL CHECKOPTIONS ()


LLHOOK = LHOOK
LHOOK = .FALSE.

OPEN (4, FILE=TRIM (CLNAMELIST), FORM='FORMATTED')

LELAM     = .FALSE.
NFLDUA    = 1
NFLDSU    = 0
NPRINTLEV = 0
NSMAX     = 0
NMSMAX    = 0
NDGLG     = 0
NFLEVG    = 19
LDEBUG    = .FALSE.

CALL POSNAM (4, 'NAMAATESTPROG')
READ (4, NAMAATESTPROG)

IF ((NSMAX == 0) .OR. (NDGLG == 0)) THEN
  CALL ABOR1 ('DWARF: NSMAX AND NDGLG ARE REQUIRED')
ENDIF

NPRGPNS = 0 
NPRGPEW = 0 
NPRTRW  = 0 
NPRTRV  = 0 

CALL POSNAM (4, 'NAMPAR0')
READ (4, NAMPAR0)

LUSEFLT   = NSMAX > 1280
LUSERPNM  = .NOT.LUSEFLT
LKEEPRPNM = .NOT.LUSEFLT

CALL POSNAM (4, 'NAMTRANS')
READ (4, NAMTRANS)

LEQ_REGIONS = .NOT. LELAM
LSPLIT      = .TRUE.

CALL POSNAM (4, 'NAMPAR1')
READ (4, NAMPAR1)

IF (LELAM) THEN
  NRGRI = NDLON
ELSE
  NRGRI = 0
ENDIF

CALL POSNAM (4, 'NAMRGRI')
READ (4, NAMRGRI)

CLOSE (4)

ALLOCATE (NLOEN (NDGLG))
NLOEN (1:NDGLG) = NRGRI (1:NDGLG)

IF (.NOT. LELAM) THEN
  IF (ANY (NLOEN (NDGLG/2+1:NDGLG) == 0)) THEN
    NLOEN (NDGLG/2+1:NDGLG) = NLOEN (NDGLG/2:1:-1)
  ENDIF
  IF (ANY (NLOEN (NDGLG/2:1:-1) /= NLOEN (NDGLG/2+1:NDGLG))) THEn
    CALL ABOR1 ('UNEXPECTED NLOEN')
  ENDIF
ENDIF


IF (LLMPOFF) THEN
  MYPROC = 1
  NPROC  = 1
ELSE
  CALL MPL_INIT 
  MYPROC = MPL_MYRANK()
  NPROC  = MPL_NPROC ()
ENDIF

! GPU binding
BLOCK
  INTEGER (KIND=JPIM) :: NDEV, IDEV, IDTY
  !$acc init
  IDTY = ACC_GET_DEVICE_TYPE ()
  NDEV = ACC_GET_NUM_DEVICES (IDTY)
  IDEV = MOD (MYPROC-1, NDEV)
  PRINT *, " MYPROC = ", MYPROC, " NDEV = ", NDEV, " IDEV = ", IDEV
  CALL ACC_SET_DEVICE_NUM (IDEV, ACC_GET_DEVICE_TYPE ())
  PRINT *, " MYPROC = ", MYPROC, " ACC_GET_DEVICE_NUM = ", ACC_GET_DEVICE_NUM (IDTY)
ENDBLOCK

IF (NPROC > 1 .AND. LLTESTHARMONICS) THEN
  CALL ABOR1 ('NPROC > 1 .AND. LLTESTHARMONICS')
ENDIF

CALL SQUARE (NPROC, IB, IA)

IF (NPRGPNS == 0 .AND. NPRGPEW == 0) THEN
  NPRGPNS = IA
  NPRGPEW = IB
ENDIF

IF (NPRTRW == 0 .AND. NPRTRV == 0) THEN
  NPRTRW = IA
  NPRTRV = IB
ENDIF

NBSETSP = MIN (NFLEVG+1, NPRTRV)

IF (MYPROC == 1) THEN

  WRITE (0, *) " NPROC = ", NPROC, " NTIME = ", NTIME, " LELAM = ", LELAM
  WRITE (0, *) " NFLDUA = ", NFLDUA, " NFLDSU = ", NFLDSU, " NFLEVG = ", NFLEVG
  WRITE (0, *) " NPRGPNS = ", NPRGPNS, " NPRGPEW = ", NPRGPEW
  WRITE (0, *) " NPRTRW = ", NPRTRW, " NPRTRV = ", NPRTRV
  WRITE (0, *) " LEQ_REGIONS = ", LEQ_REGIONS, " LSPLIT = ", LSPLIT
  WRITE (0, *) " NSMAX = ", NSMAX, " NDGLG = ", NDGLG

ENDIF

MYSETV = MOD (MYPROC-1, NPRTRV) + 1
MYSETW = (MYPROC-1) / NPRTRV + 1


CALL SETUP_TRANS0 (KOUT=0, KERR=0, KPRINTLEV=NPRINTLEV, KMAX_RESOL=2,   &
                 & KPRGPNS=NPRGPNS, KPRGPEW=NPRGPEW, KPRTRW=NPRTRW,     &
                 & LDEQ_REGIONS=LEQ_REGIONS, LDMPOFF=LLMPOFF,           &
                 & LDALLOPERM=LLALLOPERM, LDALLOPERM2=LLALLOPERM)
IF (LELAM) THEN
  CALL ESETUP_TRANS (KSMAX=NSMAX, KMSMAX=NMSMAX, KDGL=NDGLG, KDGUX=NDGLG, KLOEN=NLOEN, &
                   & LDSPLIT=LSPLIT, KFLEV=NFLEVG)
  CALL ETRANS_INQ (KSPEC2=NSPEC2, KGPTOT=NGPTOT, KSPEC2G=NSPEC2G, KGPTOTG=NGPTOTG)
ELSE
  CALL SETUP_TRANS (KSMAX=NSMAX, KDGL=NDGLG, KLOEN=NLOEN, LDSPLIT=LSPLIT, KFLEV=NFLEVG, &
                  & LDUSEFLT=LUSEFLT,LDUSERPNM=LUSERPNM, LDKEEPRPNM=LKEEPRPNM)
  CALL TRANS_INQ (KSPEC2=NSPEC2, KGPTOT=NGPTOT, KSPEC2G=NSPEC2G, KGPTOTG=NGPTOTG)
ENDIF

IF (MYPROC == 1) THEN
  WRITE (0, *) " NGPTOTG = ", NGPTOTG, " NSPEC2G = ", NSPEC2G
ENDIF

ALLOCATE (NBSETLEV (NFLEVG))

DO ILEVG = 1, NFLEVG
  NBSETLEV (ILEVG) = MOD (ILEVG, NPRTRV) + 1
ENDDO

NFLEV = COUNT (NBSETLEV == MYSETV)

IFLDGPG = NFLDSU + NFLDUA * NFLEVG 
ALLOCATE (IVSET (IFLDGPG))

DO IFLD = 1, NFLDSU
  IVSET (IFLD) = NBSETSP
ENDDO

DO IFLD = 1, NFLDUA
  DO ILEVG = 1, NFLEVG
    IVSET (NFLDSU+ILEVG+(IFLD-1)*NFLEVG) = NBSETLEV (ILEVG)
  ENDDO
ENDDO

IFLDSPL = COUNT (IVSET == MYSETV)

PRINT *, " IFLDSPL = ", IFLDSPL, " MYPROC = ", MYPROC

ALLOCATE (ZSPBUFL (IFLDSPL, NSPEC2))
ALLOCATE (ZGPBUFL (NGPTOT, IFLDGPG, 1))

CALL GENFIELD

IF (LLCHECK) THEN
  CALL CHECK (LDDIFF=.FALSE.)
ENDIF

IF (.NOT. LLNOWRITE) THEN
  CALL WRIFIELD ('AATESTPROG.0.fa')
ENDIF

IF (.NOT. LLMPOFF) CALL MPL_BARRIER()

LHOOK = LLHOOK

IF (LHOOK) CALL DR_HOOK ('AATESTPROG',0,ZHOOK_HANDLE)

IF (LLTESTHARMONICS) THEN
  CALL TESTHARMONICS
ELSE
  DO ITIME = 1, NTIME
    ZTSTEP = TIMEF()
  
    IF (LELAM) THEN
      IF (.NOT. LLNODIRTRANS) CALL EDIR_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
      IF (.NOT. LLNOINVTRANS) CALL EINV_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
    ELSE
      IF (.NOT. LLNODIRTRANS) CALL DIR_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
      IF (.NOT. LLNOINVTRANS) CALL INV_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
    ENDIF
  
    IF(MYPROC == 1) THEN
      ZTSTEP=(TIMEF()-ZTSTEP)/1000.0_JPRB
      WRITE(*,'(" time step ",I6," took", F8.2)') ITIME, ZTSTEP
    ENDIF
  ENDDO
ENDIF

CALL FLUSH (0)

IF (LELAM) THEN
  CALL ETRANS_END
ELSE
  CALL TRANS_END
ENDIF

999 CONTINUE

IF (.NOT. LLMPOFF) CALL MPL_BARRIER

IF (LHOOK) CALL DR_HOOK ('AATESTPROG',1,ZHOOK_HANDLE)

IF (.NOT. LLNOWRITE) THEN
  CALL WRIFIELD ('AATESTPROG.1.fa')
ENDIF

IF (LLCHECK) THEN
  CALL CHECK (LDDIFF=.FALSE.)
  CALL CHECK (LDDIFF=.TRUE.)
ENDIF

IF (.NOT. LLMPOFF) CALL MPL_END

IF (MYPROC == 1) WRITE (0, *) " --------- END --------- "

CALL FLUSH (0)

CONTAINS

SUBROUTINE TESTHARMONICS

INTEGER (KIND=JPIM) :: INHARM
CHARACTER (LEN=32) :: CLFILE

DO INHARM = 1, NSPEC2G

  WRITE (CLFILE, '(I6.6)') INHARM

  ZSPBUFL = 0._JPRB
  ZSPBUFL (1, INHARM) = 1._JPRB
  ZGPBUFL = 999._JPRB

  CALL EINV_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
  
! OPEN (77, FILE=TRIM (CLFILE)//'.gp.dat')
! WRITE (77, *) ZGPBUFL (:, 1, 1)
! CLOSE (77)

  ZSPBUFL = 999._JPRB

  CALL EDIR_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)

! OPEN (77, FILE=TRIM (CLFILE)//'.sp.dat')
! WRITE (77, *) ZSPBUFL (1, :)
! CLOSE (77)

  WHERE (ABS (ZSPBUFL) < 1E-15)
    ZSPBUFL = 0._JPRB
  ENDWHERE

  WHERE (ABS (ZSPBUFL - 1._JPRB) < 1E-15)
    ZSPBUFL = 1._JPRB
  ENDWHERE

  WRITE (88, '(I6," ",I6," ",I6," ",I6," ",I6)') INHARM, &
       & COUNT (ZSPBUFL (1, :) == 0._JPRB), COUNT (ZSPBUFL (1, :) == 1._JPRB), &
       & COUNT ((ZSPBUFL (1, :) /= 1._JPRB) .AND. (ZSPBUFL (1, :) /= 0._JPRB)), &
       & NSPEC2G
 

ENDDO

END SUBROUTINE

SUBROUTINE SQUARE (KN, KA, KB)

INTEGER (KIND=JPIM) :: KN, KA, KB

KB = INT (SQRT (REAL (KN))) + 1

DO
  KA = KN / KB
  IF (KA * KB == KN) EXIT
  KB = KB - 1
ENDDO

END SUBROUTINE SQUARE

SUBROUTINE POSNAM (KULNAM,CDNAML)

USE PARKIND1  ,ONLY : JPIM     ,JPRB
USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK

IMPLICIT NONE

INTEGER(KIND=JPIM),INTENT(IN)    :: KULNAM 
CHARACTER(LEN=*)  ,INTENT(IN)    :: CDNAML 


#include "abor1.intfb.h"


CHARACTER (LEN = 40) ::  CLINE
CHARACTER (LEN =  1) ::  CLTEST

INTEGER(KIND=JPIM) :: ILEN, IND1, ISTATUS, ISCAN
REAL(KIND=JPRB)    :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('POSNAM',0,ZHOOK_HANDLE)

CLINE='                                        '
REWIND(KULNAM)
ILEN=LEN(CDNAML)
ISTATUS=0
ISCAN=0
DO WHILE (ISTATUS==0 .AND. ISCAN==0)
  READ(KULNAM,'(A)',IOSTAT=ISTATUS) CLINE
  SELECT CASE (ISTATUS)
  CASE (:-1)
    CALL ABOR1 ('POSNAM: CANNOT FIND '//TRIM (CDNAML))
  CASE (0)
    IF (INDEX(CLINE(1:10),'&') == 0) THEN
      ISCAN=0
    ELSE
      IND1=INDEX(CLINE,'&'//CDNAML)
      IF (IND1 == 0) THEN
        ISCAN=0
      ELSE
        CLTEST=CLINE(IND1+ILEN+1:IND1+ILEN+1)
        IF (   (LGE(CLTEST,'0').AND.LLE(CLTEST,'9')) &
         & .OR.(LGE(CLTEST,'A').AND.LLE(CLTEST,'Z')) ) THEN
          ISCAN=0
        ELSE
          ISCAN=1
        ENDIF
      ENDIF
    ENDIF
  CASE (1:)
    CALL ABOR1 ('POSNAM: AN ERROR HAPPENED WHILE READING THE NAMELIST')
  END SELECT
ENDDO
BACKSPACE(KULNAM)

IF (LHOOK) CALL DR_HOOK('POSNAM',1,ZHOOK_HANDLE)
END SUBROUTINE POSNAM

SUBROUTINE WRIFIELD (CDFILE)

CHARACTER (LEN=*), INTENT (IN) :: CDFILE
INTEGER (KIND=JPIM) :: ITO (IFLDGPG), JFLD
CHARACTER (LEN=16) :: CLPREF, CLSUFF

ITO = 1

IF (MYPROC == 1) THEN
  ALLOCATE (ZGPBUFG (NGPTOTG, IFLDGPG))

  IF (LELAM) THEN
    CALL EGATH_GRID (PGPG=ZGPBUFG, KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPBUFL (:,:,:))
  ELSE
    CALL GATH_GRID (PGPG=ZGPBUFG, KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPBUFL (:,:,:))
  ENDIF

  CALL SYSTEM ('rm -f '//TRIM (CDFILE))

  DO JFLD = 1, IFLDGPG
    CLPREF = 'SURF'
    WRITE (CLSUFF, '("FFFF.",I4.4)') JFLD
    CALL WFA (ZGPBUFG (:, JFLD), CDFILE, CLPREF, CLSUFF)
  ENDDO

  DEALLOCATE (ZGPBUFG)
ELSE
  IF (LELAM) THEN
    CALL EGATH_GRID (KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPBUFL (:,:,:))
  ELSE
    CALL GATH_GRID (KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPBUFL (:,:,:))
  ENDIF
ENDIF

END SUBROUTINE

SUBROUTINE WFA (PGLO, CDFILE, CDPREF, CDSUFF)

REAL (KIND=JPRB),  INTENT (IN) :: PGLO (:)
CHARACTER (LEN=*), INTENT (IN) :: CDFILE, CDPREF, CDSUFF

REAL (KIND=JPRB) :: ZMU (NDGLG)

CHARACTER (LEN=3) :: CLNOMC 
REAL (KIND=JPRB) :: ZAHYBR (2), ZBHYBR (2), ZSLAPO, ZCLOPO, ZSLOPO, ZCODIL, ZREFER
INTEGER (KIND=JPIM) :: INIVER, ITYPTR, ITRONC, INLATI, INXLON
INTEGER (KIND=JPIM) :: NLOENG (NDGLG), INOZPA (NDGLG)
INTEGER (KIND=JPIM) :: INBARP, INBARI, ILUN, IREP
INTEGER (KIND=JPIM) :: INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5
INTEGER (KIND=JPIM) :: IDATEF (11), ILCHAM
CHARACTER (LEN=16)  :: CLSTATUS
LOGICAL :: LLEXIST

INQUIRE (FILE=TRIM (CDFILE), EXIST=LLEXIST)

IF (LLEXIST) THEN
  CLSTATUS = 'OLD'
  IF (LELAM) THEN
    CLNOMC = 'ALD'
  ELSE
    CLNOMC = 'ARP'
  ENDIF
ELSE
  CLSTATUS = 'NEW'
IF (LELAM) THEN
BLOCK
  INTEGER (KIND=JPIM) :: INLOPA (8)
  INTEGER (KIND=JPIM) :: NX, NY, NUX, NUY
  REAL (KIND=JPRB) :: DXINMETRES, DYINMETRES
  REAL (KIND=JPRB) :: ZSINLA (18)

  REAL (KIND=JPRB), PARAMETER :: LADINDEGREES    = 46.2_JPRB
  REAL (KIND=JPRB), PARAMETER :: LATIN1INDEGREES = 46.2_JPRB
  REAL (KIND=JPRB), PARAMETER :: LATIN2INDEGREES = 46.2_JPRB
  REAL (KIND=JPRB), PARAMETER :: LOVINDEGREES    =  2.0_JPRB

  CLNOMC = 'ALD'
  NX = NDLON
  NY = NDGLG

  ! Round dx to 100m
  DXINMETRES = 2000.E3_JPRB / REAL (NX - 1, JPRB)
  DXINMETRES = 100._JPRB * NINT (DXINMETRES / 100._JPRB) 
  DYINMETRES = DXINMETRES

  NUX = NX - 1
  NUY = NY - 1

  INLATI = NY
  INXLON = NX
  ZSLAPO = 0._JPRB
  ZCLOPO = 0._JPRB
  ZSLOPO = 0._JPRB
  ZCODIL = 0._JPRB
  ZREFER = 0._JPRB
  INIVER = 1_JPIM
  ZAHYBR = 0._JPRB
  ZBHYBR = 0._JPRB 
  INLOPA = [10_JPIM, 1_JPIM, 1_JPIM, NUX+1, 1_JPIM, NUY+1, 8_JPIM, 8_JPIM]
  ITRONC = +INLATI / 2 - 1 
  ITYPTR = -INXLON / 2 + 1 
  
  ZSINLA = [-1._JPRB, SIN (DEG2RAD * LADINDEGREES), DEG2RAD * LOVINDEGREES, DEG2RAD * LADINDEGREES, &
         &  DEG2RAD * LOVINDEGREES, DEG2RAD * LADINDEGREES, DXINMETRES, DYINMETRES, &
         &  INXLON * DXINMETRES, INLATI * DYINMETRES, 0._JPRB, 0._JPRB, 0._JPRB, &
         &  0._JPRB, 0._JPRB, 0._JPRB, 0._JPRB, 0._JPRB ]
  
  CALL FACADE (CLNOMC, ITYPTR, ZSLAPO, ZCLOPO, ZSLOPO, &
  &            ZCODIL, ITRONC, INLATI, INXLON, INLOPA, &
  &            INOZPA, ZSINLA, INIVER, ZREFER, ZAHYBR, &
  &            ZBHYBR, .FALSE.)

ENDBLOCK
ELSE
BLOCK
  REAL (KIND=JPRB) :: ZCENTRE (2)

  CLNOMC = 'ARP'

  CALL TRANS_INQ (PMU=ZMU)
  
  ZCENTRE = [0._JPRB, 90._JPRB]
  ZCODIL = 1._JPRB
  
  INIVER = 1_JPIM
  ZAHYBR = 0._JPRB
  ZBHYBR = 0._JPRB
  ITYPTR = 2_JPIM
  
  NLOENG = NLOEN
  
  ZSLAPO = SIN (ZCENTRE (2) * DEG2RAD)
  ZCLOPO = COS (ZCENTRE (1) * DEG2RAD)
  ZSLOPO = SIN (ZCENTRE (1) * DEG2RAD)
  INLATI = NDGLG
  INXLON = MAXVAL (NLOENG)
  ITRONC = INXLON / 3
  INOZPA = MIN (ITRONC, NLOENG/2_JPIM-1_JPIM)
  ZREFER = 1._JPRB
  
  CALL FACADE (CLNOMC, ITYPTR, ZSLAPO, ZCLOPO, ZSLOPO, &
  &            ZCODIL, ITRONC, INLATI, INXLON, NLOENG, &
  &            INOZPA, ZMU,    INIVER, ZREFER, ZAHYBR, &
  &            ZBHYBR, .FALSE.)

ENDBLOCK
ENDIF
ENDIF
 

INBARP = 0
INBARI = 0
ILUN = 77
CALL FAITOU (IREP, ILUN, .TRUE., TRIM (CDFILE), CLSTATUS, .TRUE., &
           & .TRUE., 2_JPIM, INBARP, INBARI, CLNOMC)

IDATEF = [1990,  2, 15, 12,  0,   1,  0, 24,   1, 0, 0]
CALL FANDAR (IREP, ILUN, IDATEF)

CALL FATCHA (IREP, CLNOMC, .FALSE., ILCHAM)

CALL FAVEUR (IREP, ILUN, INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5)
INGRIB = 123_JPIM
CALL FAGOTE (IREP, ILUN, INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5)

CALL FAIENC (IREP, ILUN, CDPREF, 0, CDSUFF, PGLO, .FALSE.)

CALL FAIRME (IREP, ILUN, 'KEEP')

END SUBROUTINE

SUBROUTINE CHECK (LDDIFF)

LOGICAL, INTENT (IN) :: LDDIFF

! Save result in ZGPBUFL1

REAL (KIND=JPRB),    ALLOCATABLE :: ZGPBUFL1 (:,:,:) 
REAL (KIND=JPRB),    ALLOCATABLE :: ZGPBUFG1 (:,:) 
INTEGER (KIND=JPIM) :: JFLD, ITO (1)
REAL (KIND=JPRB) :: ZDIFF2 (IFLDGPG)

ALLOCATE (ZGPBUFL1 (NGPTOT, IFLDGPG, 1)) 

ZGPBUFL1 = ZGPBUFL

! Recreate original field


IF (LDDIFF) THEN
  CALL GENFIELD
  ZGPBUFL1 = ZGPBUFL1 - ZGPBUFL
ENDIF

IF (MYPROC == 1) THEN
  IF (LDDIFF) THEN
    WRITE (100, *) "                  ------------- DIFF ------------- "
  ELSE
    WRITE (100, *) "                  ------------- STAT ------------- "
  ENDIF
ENDIF

ITO = 1

DO JFLD = 1, IFLDGPG

  IF (MYPROC == 1) THEN
    ALLOCATE (ZGPBUFG1 (NGPTOTG, 1))
    IF (LELAM) THEN
      CALL EGATH_GRID (PGPG=ZGPBUFG1, KFGATHG=1, KTO=ITO, PGP=ZGPBUFL1 (:,JFLD:JFLD,:))
    ELSE
      CALL GATH_GRID (PGPG=ZGPBUFG1, KFGATHG=1, KTO=ITO, PGP=ZGPBUFL1 (:,JFLD:JFLD,:))
    ENDIF
    WRITE (100, '(" FIELD ",I6," L2 =",E16.8," L1 = ",E16.8," MEAN =",E16.8)') & 
         & JFLD, SQRT (SUM (ZGPBUFG1 * ZGPBUFG1) / REAL (NGPTOTG, JPRB)), &
         & SUM (ABS (ZGPBUFG1)) / REAL (NGPTOTG, JPRB), SUM (ZGPBUFG1)
    DEALLOCATE (ZGPBUFG1)
  ELSE
    IF (LELAM) THEN
      CALL EGATH_GRID (KFGATHG=1, KTO=ITO, PGP=ZGPBUFL1 (:,JFLD:JFLD,:))
    ELSE
      CALL GATH_GRID (KFGATHG=1, KTO=ITO, PGP=ZGPBUFL1 (:,JFLD:JFLD,:))
    ENDIF
  ENDIF

ENDDO

END SUBROUTINE

SUBROUTINE GENFIELD

IF (MYPROC == 1) THEN
  ALLOCATE (ZGPBUFG (NGPTOTG, 1))

  IF (CLFIELD /= '') THEN
    OPEN (77, FILE=TRIM (CLFIELD), FORM='UNFORMATTED', STATUS='OLD')
    READ (77) ZGPBUFG (:, 1)
    CLOSE (77)
  ELSE
  BLOCK
    REAL (KIND=JPRB) :: ZLON, ZLAT, ZVAL, ZX, ZY
    INTEGER (KIND=JPIM) :: JLAT, JLON, JGLO

    JGLO = 1

    DO JLAT = 1, NDGLG
      DO JLON = 1, NLOEN (JLAT)
       
        IF (LELAM) THEN
          ZX = REAL (JLON-1, JPRB) / REAL (NDLON, JPRB)
          ZY = REAL (JLAT-1, JPRB) / REAL (NDLON, JPRB)
          ZVAL = ZX * (1._JPRB - ZX) * ZY * (1._JPRB - ZY) * 4._JPRB + 0.5
        ELSE
          ZLAT = + RPI * (0.5_JPRB - REAL (JLAT, JPRB) / REAL (NDGLG+1, JPRB))
          ZLON = 2 * RPI * REAL (JLON-1, JPRB) / REAL (NLOEN (JLAT))
          ZVAL = COS (ZLAT) * SIN (ZLON)
        ENDIF
        ZGPBUFG (JGLO, 1) = ZVAL
        JGLO = JGLO + 1
      ENDDO
    ENDDO
  ENDBLOCK
  ENDIF

  IF (LELAM) THEN
    CALL EDIST_GRID (PGPG=ZGPBUFG, KFDISTG=1_JPIM, KFROM=[1_JPIM], PGP=ZGPBUFL (:,1:1,:))
  ELSE
    CALL DIST_GRID (PGPG=ZGPBUFG, KFDISTG=1_JPIM, KFROM=[1_JPIM], PGP=ZGPBUFL (:,1:1,:))
  ENDIF

  DEALLOCATE (ZGPBUFG)

ELSE
  IF (LELAM) THEN
    CALL EDIST_GRID (KFDISTG=1_JPIM, KFROM=[1_JPIM], PGP=ZGPBUFL (:,1:1,:))
  ELSE
    CALL DIST_GRID (KFDISTG=1_JPIM, KFROM=[1_JPIM], PGP=ZGPBUFL (:,1:1,:))
  ENDIF
ENDIF

DO IFLD = 2, IFLDGPG
  ZGPBUFL (:, IFLD, 1) = ZGPBUFL (:, 1, 1) * REAL (IFLD, JPRB)
ENDDO


END SUBROUTINE

END PROGRAM TEST

