PROGRAM TEST

USE MPL_END_MOD, ONLY : MPL_END
USE MPL_INIT_MOD, ONLY : MPL_INIT
USE PARKIND1, ONLY : JPIM, JPRB
USE MPL_MODULE, ONLY : MPL_BARRIER, MPL_MYRANK, MPL_NPROC
USE MPL_DATA_MODULE, ONLY : MPL_COMM_OML
USE YOMHOOK, ONLY : DR_HOOK, LHOOK
USE SET2PE_MOD, ONLY : SET2PE

USE XRD_GETOPTIONS

IMPLICIT NONE

REAL (KIND=JPRB), PARAMETER :: RPI = 2._JPRB * ASIN (1.0_JPRB)
REAL (KIND=JPRB), PARAMETER :: DEG2RAD = RPI / 180._JPRB

INTEGER(KIND=JPIM) :: NMSMAX, NSMAX, NDGLG, NPRGPNS, NPRGPEW, NPRTRW, NPRTRV, NDLON, NPRINTLEV, NTIME
INTEGER(KIND=JPIM) :: MYPROC, NPROC, NBSETSP
INTEGER(KIND=JPIM) :: NFLEV
INTEGER(KIND=JPIM) :: NFLEVG
INTEGER(KIND=JPIM) :: NSPEC2, NSPEC2G, NGPTOT, NGPTOTG, MYSETV, MYSETW
INTEGER(KIND=JPIM), ALLOCATABLE :: NLOEN (:) 
INTEGER(KIND=JPIM), ALLOCATABLE :: IFLDSCH (:) 
INTEGER(KIND=JPIM), ALLOCATABLE :: IVSETOFF (:)
INTEGER(KIND=JPIM), POINTER     :: INFD (:), IFLDOFF (:)

REAL (KIND=JPRB) :: ZTSTEP, TIMEF

REAL (KIND=JPRB),    ALLOCATABLE :: ZSPVOR (:,:), ZSPDIV (:,:)
REAL (KIND=JPRB),    ALLOCATABLE :: ZGPUV (:,:,:,:), ZMEANU (:), ZMEANV (:)
INTEGER (KIND=JPIM), ALLOCATABLE :: NBSETLEV (:) 
INTEGER (KIND=JPIM), ALLOCATABLE :: IVSET (:) 
INTEGER (KIND=JPIM) :: NFLDUA, NFLDSU, IFLD, ILEVG, IGPG, JFLDG1, JFLDG2, IPROC
INTEGER (KIND=JPIM) :: JSETW, JSETV
INTEGER (KIND=JPIM) :: IFLDGPG, IFLDSPL
INTEGER (KIND=JPIM) :: IA, IB
INTEGER (KIND=JPIM) :: NRGRI (8000)
INTEGER (KIND=JPIM) :: ITIME

LOGICAL :: LUSEFLT, LUSERPNM, LKEEPRPNM
LOGICAL :: LSPLIT, LEQ_REGIONS, LDEBUG, LELAM
LOGICAL :: LLHOOK

#include "setup_trans0.h"

#include "setup_trans.h"
#include "trans_inq.h"
#include "dist_grid.h"
#include "gath_grid.h"
#include "dir_trans.h"
#include "inv_trans.h"

#include "esetup_trans.h"
#include "etrans_inq.h"
#include "edist_grid.h"
#include "egath_grid.h"
#include "edir_trans.h"
#include "einv_trans.h"

#include "abor1.intfb.h"

NAMELIST / NAMAATESTPROG / & 
  & NFLDUA, NFLDSU, NMSMAX, NSMAX, NDGLG, NFLEVG, LDEBUG, NDLON, NPRINTLEV, NTIME, LELAM

NAMELIST / NAMTRANS / & 
  & LUSEFLT, LUSERPNM, LKEEPRPNM

NAMELIST / NAMPAR0 / & 
  & NPRGPNS, NPRGPEW, NPRTRW, NPRTRV

NAMELIST / NAMPAR1 / & 
  & LEQ_REGIONS, LSPLIT

NAMELIST / NAMRGRI / & 
  & NRGRI

CHARACTER (LEN=64) :: CLNAMELIST, CLFIELDU, CLFIELDV
LOGICAL :: LLMPOFF, LLNOWRITE

REAL (KIND=JPRB) :: ZHOOK_HANDLE

CALL INITOPTIONS ()
CLNAMELIST = 'fort.4'
CALL GETOPTION ("--namelist", CLNAMELIST)
CALL GETOPTION ("--lmpoff", LLMPOFF)
NTIME     = 10
CALL GETOPTION ("--time", NTIME)
CLFIELDU = ''; CALL GETOPTION ("--u-file", CLFIELDU)
CLFIELDV = ''; CALL GETOPTION ("--v-file", CLFIELDV)
CALL GETOPTION ("--no-write", LLNOWRITE)
CALL CHECKOPTIONS ()


LLHOOK = LHOOK
LHOOK = .FALSE.

OPEN (4, FILE=TRIM (CLNAMELIST), FORM='FORMATTED')

LELAM     = .FALSE.
NFLDUA    = 1
NFLDSU    = 0
NPRINTLEV = 0
NSMAX     = 0
NMSMAX    = 0
NDGLG     = 0
NFLEVG    = 19
LDEBUG    = .FALSE.

CALL POSNAM (4, 'NAMAATESTPROG')
READ (4, NAMAATESTPROG)

IF ((NSMAX == 0) .OR. (NDGLG == 0)) THEN
  CALL ABOR1 ('DWARF: NSMAX AND NDGLG ARE REQUIRED')
ENDIF

NPRGPNS = 0 
NPRGPEW = 0 
NPRTRW  = 0 
NPRTRV  = 0 

CALL POSNAM (4, 'NAMPAR0')
READ (4, NAMPAR0)

LUSEFLT   = NSMAX > 1280
LUSERPNM  = .NOT.LUSEFLT
LKEEPRPNM = .NOT.LUSEFLT

CALL POSNAM (4, 'NAMTRANS')
READ (4, NAMTRANS)

LEQ_REGIONS = .NOT. LELAM
LSPLIT      = .TRUE.


CALL POSNAM (4, 'NAMPAR1')
READ (4, NAMPAR1)

IF (LELAM) THEN
  NRGRI = NDLON
ELSE
  NRGRI = 0
ENDIF

CALL POSNAM (4, 'NAMRGRI')
READ (4, NAMRGRI)

CLOSE (4)

ALLOCATE (NLOEN (NDGLG))
NLOEN (1:NDGLG) = NRGRI (1:NDGLG)

IF (.NOT. LELAM) THEN
  IF (ANY (NLOEN (NDGLG/2+1:NDGLG) == 0)) THEN
    NLOEN (NDGLG/2+1:NDGLG) = NLOEN (NDGLG/2:1:-1)
  ENDIF
  IF (ANY (NLOEN (NDGLG/2:1:-1) /= NLOEN (NDGLG/2+1:NDGLG))) THEn
    CALL ABOR1 ('UNEXPECTED NLOEN')
  ENDIF
ENDIF

IF (LLMPOFF) THEN
  MYPROC = 1
  NPROC  = 1
ELSE
  CALL MPL_INIT 
  MYPROC = MPL_MYRANK()
  NPROC  = MPL_NPROC ()
ENDIF

! GPU binding

CALL GPU_BIND (MYPROC-1, NPROC)

CALL SQUARE (NPROC, IB, IA)

IF (NPRGPNS == 0 .AND. NPRGPEW == 0) THEN
  NPRGPNS = IA
  NPRGPEW = IB
ENDIF

IF (NPRTRW == 0 .AND. NPRTRV == 0) THEN
  NPRTRW = IA
  NPRTRV = IB
ENDIF

NBSETSP = MIN (NFLEVG+1, NPRTRV)

IF (MYPROC == 1) THEN

  WRITE (0, *) " NPROC = ", NPROC, " NTIME = ", NTIME, " LELAM = ", LELAM
  WRITE (0, *) " NFLDUA = ", NFLDUA, " NFLDSU = ", NFLDSU, " NFLEVG = ", NFLEVG
  WRITE (0, *) " NPRGPNS = ", NPRGPNS, " NPRGPEW = ", NPRGPEW
  WRITE (0, *) " NPRTRW = ", NPRTRW, " NPRTRV = ", NPRTRV
  WRITE (0, *) " LEQ_REGIONS = ", LEQ_REGIONS, " LSPLIT = ", LSPLIT
  WRITE (0, *) " NSMAX = ", NSMAX, " NDGLG = ", NDGLG

ENDIF

MYSETV = MOD (MYPROC-1, NPRTRV) + 1
MYSETW = (MYPROC-1) / NPRTRV + 1


CALL SETUP_TRANS0 (KOUT=0, KERR=0, KPRINTLEV=NPRINTLEV, KMAX_RESOL=2,   &
                 & KPRGPNS=NPRGPNS, KPRGPEW=NPRGPEW, KPRTRW=NPRTRW,     &
                 & LDEQ_REGIONS=LEQ_REGIONS, LDMPOFF=LLMPOFF)
IF (LELAM) THEN
  CALL ESETUP_TRANS (KSMAX=NSMAX, KMSMAX=NMSMAX, KDGL=NDGLG, KDGUX=NDGLG, KLOEN=NLOEN, &
                   & LDSPLIT=LSPLIT, KFLEV=NFLEVG, PEXWN=1._JPRB, PEYWN=1._JPRB)
  CALL ETRANS_INQ (KSPEC2=NSPEC2, KGPTOT=NGPTOT, KSPEC2G=NSPEC2G, KGPTOTG=NGPTOTG)
ELSE
  CALL SETUP_TRANS (KSMAX=NSMAX, KDGL=NDGLG, KLOEN=NLOEN, LDSPLIT=LSPLIT, KFLEV=NFLEVG, &
                  & LDUSEFLT=LUSEFLT,LDUSERPNM=LUSERPNM, LDKEEPRPNM=LKEEPRPNM)
  CALL TRANS_INQ (KSPEC2=NSPEC2, KGPTOT=NGPTOT, KSPEC2G=NSPEC2G, KGPTOTG=NGPTOTG)
ENDIF

ALLOCATE (NBSETLEV (NFLEVG))

DO ILEVG = 1, NFLEVG
  NBSETLEV (ILEVG) = MOD (ILEVG, NPRTRV) + 1
ENDDO

NFLEV = COUNT (NBSETLEV == MYSETV)

IFLDGPG = NFLDSU + NFLDUA * NFLEVG 
ALLOCATE (IVSET (IFLDGPG))

DO IFLD = 1, NFLDSU
  IVSET (IFLD) = NBSETSP
ENDDO

DO IFLD = 1, NFLDUA
  DO ILEVG = 1, NFLEVG
    IVSET (NFLDSU+ILEVG+(IFLD-1)*NFLEVG) = NBSETLEV (ILEVG)
  ENDDO
ENDDO

IFLDSPL = COUNT (IVSET == MYSETV)

ALLOCATE (ZSPDIV (IFLDSPL, NSPEC2), ZSPVOR (IFLDSPL, NSPEC2))
ALLOCATE (ZGPUV (NGPTOT, IFLDGPG, 2, 1), ZMEANU (IFLDSPL), ZMEANV (IFLDSPL))

CALL GENFIELD

IF (.NOT. LLMPOFF) CALL MPL_BARRIER()

LHOOK = LLHOOK

IF (LHOOK) CALL DR_HOOK ('AATESTPROG',0,ZHOOK_HANDLE)

IF (.NOT. LLNOWRITE) CALL WRIFIELD ('AATESTPROG.0.fa')

#ifndef UNDEF
DO ITIME = 1, NTIME
  ZTSTEP = TIMEF()

  IF (LELAM) THEN

ZSPDIV = 0.
ZSPVOR = 0.
ZMEANU = 0.
ZMEANV = 0.

    CALL EDIR_TRANS (PSPDIV=ZSPDIV, PSPVOR=ZSPVOR, PGPUV=ZGPUV, KVSETUV=IVSET, PMEANU=ZMEANU, PMEANV=ZMEANV)

WRITE (0, '(" ZMEANU = ",10E12.4)') ZMEANU
WRITE (0, '(" ZMEANV = ",10E12.4)') ZMEANV

DO IFLD = 1, IFLDSPL
  WRITE (0, '(" DIV = ",I6,1000E12.4)') IFLD, ZSPDIV (IFLD, 47), ZSPDIV (IFLD, 49), ZSPDIV (IFLD, 51)
  WRITE (0, '(" VOR = ",I6,1000E12.4)') IFLD, ZSPVOR (IFLD, 10), ZSPVOR (IFLD, 14), ZSPVOR (IFLD, 22)
ENDDO



    CALL EINV_TRANS (PSPDIV=ZSPDIV, PSPVOR=ZSPVOR, PGPUV=ZGPUV, KVSETUV=IVSET, PMEANU=ZMEANU, PMEANV=ZMEANV)
  ELSE
    CALL DIR_TRANS (PSPDIV=ZSPDIV, PSPVOR=ZSPVOR, PGPUV=ZGPUV, KVSETUV=IVSET)
    CALL INV_TRANS (PSPDIV=ZSPDIV, PSPVOR=ZSPVOR, PGPUV=ZGPUV, KVSETUV=IVSET)
  ENDIF

  IF(MYPROC == 1) THEN
    ZTSTEP=(TIMEF()-ZTSTEP)/1000.0_JPRB
    WRITE(*,'(" time step ",I6," took", F8.2)') ITIME, ZTSTEP
  ENDIF
ENDDO
#else

BLOCK
INTEGER :: INHARMU, INHARMV, JSP
CHARACTER (LEN=64) :: CLFILE

DO INHARMU= 1, 484 
  WRITE (CLFILE, '("20x20/AATESTPROG.20x20.gp.",I6.6,".dat")') INHARMU
  OPEN (77, FILE=TRIM (CLFILE), FORM='UNFORMATTED')
  READ (77) ZGPUV (:, 1, 1, 1)
  CLOSE (77)

  WRITE (CLFILE, '("sp.",I6.6,".dat")') INHARMU
  OPEN (88, FILE=TRIM (CLFILE), FORM='FORMATTED')

DO INHARMV= 1, 484 
  WRITE (CLFILE, '("20x20/AATESTPROG.20x20.gp.",I6.6,".dat")') INHARMV
  OPEN (77, FILE=TRIM (CLFILE), FORM='UNFORMATTED')
  READ (77) ZGPUV (:, 1, 2, 1)
  CLOSE (77)

  CALL EDIR_TRANS (PSPDIV=ZSPDIV, PSPVOR=ZSPVOR, PGPUV=ZGPUV, KVSETUV=IVSET, PMEANU=ZMEANU, PMEANV=ZMEANV)

  WHERE (ABS (ZSPVOR) < 1E-13)
    ZSPVOR = 0._JPRB
  ENDWHERE
  
  WHERE (ABS (ZSPDIV) < 1E-13)
    ZSPDIV = 0._JPRB
  ENDWHERE
  
  WRITE (88, *) INHARMU, INHARMV
  DO JSP = 1, NSPEC2G
    IF (ABS (ZSPVOR (1,JSP)) > 1E-13 .OR. ABS (ZSPDIV (1,JSP)) > 1E-13) THEN
      WRITE (88, '(I4,E20.8,E20.8)') JSP, ZSPVOR (1,JSP), ZSPDIV (1,JSP)
    ENDIF
  ENDDO
 
! CALL EINV_TRANS (PSPDIV=ZSPDIV, PSPVOR=ZSPVOR, PGPUV=ZGPUV, KVSETUV=IVSET, PMEANU=ZMEANU, PMEANV=ZMEANV)
ENDDO

  CLOSE (88)

ENDDO

ENDBLOCK


#endif


IF (LELAM) THEN
  CALL ETRANS_END
ELSE
  CALL TRANS_END
ENDIF

IF (.NOT. LLMPOFF) CALL MPL_BARRIER

IF (LHOOK) CALL DR_HOOK ('AATESTPROG',1,ZHOOK_HANDLE)

IF (.NOT. LLNOWRITE) CALL WRIFIELD ('AATESTPROG.1.fa')

IF (.NOT. LLMPOFF) CALL MPL_END

IF (MYPROC == 1) WRITE (0, *) " --------- END --------- "

CONTAINS

SUBROUTINE SQUARE (KN, KA, KB)

INTEGER (KIND=JPIM) :: KN, KA, KB

KB = INT (SQRT (REAL (KN))) + 1

DO
  KA = KN / KB
  IF (KA * KB == KN) EXIT
  KB = KB - 1
ENDDO

END SUBROUTINE SQUARE

SUBROUTINE POSNAM (KULNAM,CDNAML)

USE PARKIND1  ,ONLY : JPIM     ,JPRB
USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK

IMPLICIT NONE

INTEGER(KIND=JPIM),INTENT(IN)    :: KULNAM 
CHARACTER(LEN=*)  ,INTENT(IN)    :: CDNAML 


#include "abor1.intfb.h"


CHARACTER (LEN = 40) ::  CLINE
CHARACTER (LEN =  1) ::  CLTEST

INTEGER(KIND=JPIM) :: ILEN, IND1, ISTATUS, ISCAN
REAL(KIND=JPRB)    :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('POSNAM',0,ZHOOK_HANDLE)

CLINE='                                        '
REWIND(KULNAM)
ILEN=LEN(CDNAML)
ISTATUS=0
ISCAN=0
DO WHILE (ISTATUS==0 .AND. ISCAN==0)
  READ(KULNAM,'(A)',IOSTAT=ISTATUS) CLINE
  SELECT CASE (ISTATUS)
  CASE (:-1)
    CALL ABOR1 ('POSNAM: CANNOT FIND '//TRIM (CDNAML))
  CASE (0)
    IF (INDEX(CLINE(1:10),'&') == 0) THEN
      ISCAN=0
    ELSE
      IND1=INDEX(CLINE,'&'//CDNAML)
      IF (IND1 == 0) THEN
        ISCAN=0
      ELSE
        CLTEST=CLINE(IND1+ILEN+1:IND1+ILEN+1)
        IF (   (LGE(CLTEST,'0').AND.LLE(CLTEST,'9')) &
         & .OR.(LGE(CLTEST,'A').AND.LLE(CLTEST,'Z')) ) THEN
          ISCAN=0
        ELSE
          ISCAN=1
        ENDIF
      ENDIF
    ENDIF
  CASE (1:)
    CALL ABOR1 ('POSNAM: AN ERROR HAPPENED WHILE READING THE NAMELIST')
  END SELECT
ENDDO
BACKSPACE(KULNAM)

IF (LHOOK) CALL DR_HOOK('POSNAM',1,ZHOOK_HANDLE)
END SUBROUTINE POSNAM

SUBROUTINE WRIFIELD (CDFILE)

CHARACTER (LEN=*), INTENT (IN) :: CDFILE
REAL (KIND=JPRB), ALLOCATABLE :: ZGPBUFG (:, :)
INTEGER (KIND=JPIM) :: ITO (IFLDGPG), JFLD
CHARACTER (LEN=16) :: CLPREF

ITO = 1_JPIM

IF (MYPROC == 1) THEN
  ALLOCATE (ZGPBUFG (NGPTOTG, IFLDGPG))
  CALL SYSTEM ('rm -f '//TRIM (CDFILE))
  CALL GATH_GRID (PGPG=ZGPBUFG, KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPUV (:,:,1,:))
  DO JFLD = 1, IFLDGPG
    WRITE (CLPREF, '("WW",I2.2)') JFLD
    CALL WFA (ZGPBUFG (:, JFLD), CDFILE, CLPREF, 'U')
  ENDDO
  CALL GATH_GRID (PGPG=ZGPBUFG, KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPUV (:,:,2,:))
  DO JFLD = 1, IFLDGPG
    WRITE (CLPREF, '("WW",I2.2)') JFLD
    CALL WFA (ZGPBUFG (:, JFLD), CDFILE, CLPREF, 'V')
  ENDDO
  DEALLOCATE (ZGPBUFG)
ELSE
  CALL GATH_GRID (KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPUV (:,:,1,:))
  CALL GATH_GRID (KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPUV (:,:,2,:))
ENDIF

END SUBROUTINE

SUBROUTINE WFA (PGLO, CDFILE, CDPREF, CDSUFF)

REAL (KIND=JPRB),  INTENT (IN) :: PGLO (:)
CHARACTER (LEN=*), INTENT (IN) :: CDFILE
CHARACTER (LEN=*), INTENT (IN) :: CDPREF, CDSUFF

REAL (KIND=JPRB) :: ZMU (NDGLG)

CHARACTER (LEN=3) :: CLNOMC 
REAL (KIND=JPRB) :: ZAHYBR (2), ZBHYBR (2), ZSLAPO, ZCLOPO, ZSLOPO, ZCODIL, ZREFER
INTEGER (KIND=JPIM) :: INIVER, ITYPTR, ITRONC, INLATI, INXLON
INTEGER (KIND=JPIM) :: NLOENG (NDGLG), INOZPA (NDGLG)
INTEGER (KIND=JPIM) :: INBARP, INBARI, ILUN, IREP
INTEGER (KIND=JPIM) :: INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5
INTEGER (KIND=JPIM) :: IDATEF (11), ILCHAM
LOGICAL :: LLEXIST
CHARACTER (LEN=32) :: CLSTATUS

INQUIRE (FILE=TRIM (CDFILE), EXIST=LLEXIST)

IF (LLEXIST) THEN
CLSTATUS = 'OLD'
IF (LELAM) THEN
  CLNOMC = 'ALD'
ELSE
  CLNOMC = 'ARP'
ENDIF
ELSE
CLSTATUS = 'NEW'
IF (LELAM) THEN
BLOCK
  INTEGER (KIND=JPIM) :: INLOPA (8)
  INTEGER (KIND=JPIM) :: NX, NY, NUX, NUY
  REAL (KIND=JPRB) :: DXINMETRES, DYINMETRES
  REAL (KIND=JPRB) :: ZSINLA (18)

  REAL (KIND=JPRB), PARAMETER :: LADINDEGREES    = 46.2_JPRB
  REAL (KIND=JPRB), PARAMETER :: LATIN1INDEGREES = 46.2_JPRB
  REAL (KIND=JPRB), PARAMETER :: LATIN2INDEGREES = 46.2_JPRB
  REAL (KIND=JPRB), PARAMETER :: LOVINDEGREES    =  2.0_JPRB

  CLNOMC = 'ALD'
  NX = NDLON
  NY = NDGLG

  ! Round dx to 100m
  DXINMETRES = 2000.E3_JPRB / REAL (NX - 1, JPRB)
  DXINMETRES = 100._JPRB * NINT (DXINMETRES / 100._JPRB) 
  DYINMETRES = DXINMETRES

  NUX = NX - 1
  NUY = NY - 1

  INLATI = NY
  INXLON = NX
  ZSLAPO = 0._JPRB
  ZCLOPO = 0._JPRB
  ZSLOPO = 0._JPRB
  ZCODIL = 0._JPRB
  ZREFER = 0._JPRB
  INIVER = 1_JPIM
  ZAHYBR = 0._JPRB
  ZBHYBR = 0._JPRB 
  INLOPA = [10_JPIM, 1_JPIM, 1_JPIM, NUX+1, 1_JPIM, NUY+1, 8_JPIM, 8_JPIM]
  ITRONC = +INLATI / 2 - 1 
  ITYPTR = -INXLON / 2 + 1 
  
  ZSINLA = [-1._JPRB, SIN (DEG2RAD * LADINDEGREES), DEG2RAD * LOVINDEGREES, DEG2RAD * LADINDEGREES, &
         &  DEG2RAD * LOVINDEGREES, DEG2RAD * LADINDEGREES, DXINMETRES, DYINMETRES, &
         &  INXLON * DXINMETRES, INLATI * DYINMETRES, 0._JPRB, 0._JPRB, 0._JPRB, &
         &  0._JPRB, 0._JPRB, 0._JPRB, 0._JPRB, 0._JPRB ]
  
  CALL FACADE (CLNOMC, ITYPTR, ZSLAPO, ZCLOPO, ZSLOPO, &
  &            ZCODIL, ITRONC, INLATI, INXLON, INLOPA, &
  &            INOZPA, ZSINLA, INIVER, ZREFER, ZAHYBR, &
  &            ZBHYBR, .FALSE.)

ENDBLOCK
ELSE
BLOCK
  REAL (KIND=JPRB) :: ZCENTRE (2)

  CLNOMC = 'ARP'

  CALL TRANS_INQ (PMU=ZMU)
  
  ZCENTRE = [0._JPRB, 90._JPRB]
  ZCODIL = 1._JPRB
  
  INIVER = 1_JPIM
  ZAHYBR = 0._JPRB
  ZBHYBR = 0._JPRB
  ITYPTR = 2_JPIM
  
  NLOENG = NLOEN
  
  ZSLAPO = SIN (ZCENTRE (2) * DEG2RAD)
  ZCLOPO = COS (ZCENTRE (1) * DEG2RAD)
  ZSLOPO = SIN (ZCENTRE (1) * DEG2RAD)
  INLATI = NDGLG
  INXLON = MAXVAL (NLOENG)
  ITRONC = INXLON / 3
  INOZPA = MIN (ITRONC, NLOENG/2_JPIM-1_JPIM)
  ZREFER = 1._JPRB
  
  CALL FACADE (CLNOMC, ITYPTR, ZSLAPO, ZCLOPO, ZSLOPO, &
  &            ZCODIL, ITRONC, INLATI, INXLON, NLOENG, &
  &            INOZPA, ZMU,    INIVER, ZREFER, ZAHYBR, &
  &            ZBHYBR, .FALSE.)

ENDBLOCK
ENDIF
ENDIF

INBARP = 0
INBARI = 0
ILUN = 77
CALL FAITOU (IREP, ILUN, .TRUE., TRIM (CDFILE), TRIM (CLSTATUS), &
           & .TRUE., .TRUE., 2_JPIM, INBARP, INBARI, CLNOMC)

IF (.NOT. LLEXIST) THEN
IDATEF = [1990,  2, 15, 12,  0,   1,  0, 24,   1, 0, 0]
CALL FANDAR (IREP, ILUN, IDATEF)
ENDIF

CALL FATCHA (IREP, CLNOMC, .FALSE., ILCHAM)

CALL FAVEUR (IREP, ILUN, INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5)
INGRIB = 123_JPIM
CALL FAGOTE (IREP, ILUN, INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5)

CALL FAIENC (IREP, ILUN, TRIM (CDPREF), 0, TRIM (CDSUFF), PGLO, .FALSE.)

CALL FAIRME (IREP, ILUN, 'KEEP')

END SUBROUTINE

SUBROUTINE GENFIELD

REAL (KIND=JPRB), ALLOCATABLE :: ZGPBUFG (:, :)


IF (MYPROC == 1) THEN
  ALLOCATE (ZGPBUFG (NGPTOTG, 2))

  IF ((TRIM (CLFIELDU) /= '') .AND. (TRIM (CLFIELDV) /= '')) THEN
    OPEN (77, FILE=TRIM (CLFIELDU), FORM='UNFORMATTED', STATUS='OLD')
    READ (77) ZGPBUFG (:,1)
    CLOSE (77)
    OPEN (77, FILE=TRIM (CLFIELDV), FORM='UNFORMATTED', STATUS='OLD')
    READ (77) ZGPBUFG (:,2)
    CLOSE (77)
  ELSE
  BLOCK
    REAL (KIND=JPRB) :: ZLON, ZLAT, ZU, ZV, ZX, ZY
    INTEGER (KIND=JPIM) :: JLAT, JLON, JGLO

    JGLO = 1

    DO JLAT = 1, NDGLG
      DO JLON = 1, NLOEN (JLAT)
       
        IF (LELAM) THEN
          ZX = REAL (JLON-1, JPRB) / REAL (NDLON, JPRB)
          ZY = REAL (JLAT-1, JPRB) / REAL (NDLON, JPRB)
          ZU = ZX * (1._JPRB - ZX) * ZY * (1._JPRB - ZY) * 4._JPRB
          ZV = COS (2 * RPI * ZX) * SIN (2 * RPI * ZY)
        ELSE
          ZLAT = + RPI * (0.5_JPRB - REAL (JLAT, JPRB) / REAL (NDGLG+1, JPRB))
          ZLON = 2 * RPI * REAL (JLON-1, JPRB) / REAL (NLOEN (JLAT))
          ZU = COS (2 * ZLAT - RPI / 2) * SIN (ZLON)
          ZV = COS (3 * ZLAT) * COS (ZLON)
        ENDIF
        ZGPBUFG (JGLO, 1) = ZU + 0.5
        ZGPBUFG (JGLO, 2) = ZV - 0.5
        JGLO = JGLO + 1
      ENDDO
    ENDDO
  ENDBLOCK
  ENDIF

  IF (LELAM) THEN
    CALL EDIST_GRID (PGPG=ZGPBUFG, KFDISTG=2_JPIM, KFROM=[1_JPIM, 1_JPIM], PGP=ZGPUV (:,1,1:2,:))
  ELSE
    CALL DIST_GRID (PGPG=ZGPBUFG, KFDISTG=2_JPIM, KFROM=[1_JPIM, 1_JPIM], PGP=ZGPUV (:,1,1:2,:))
  ENDIF

  DEALLOCATE (ZGPBUFG)
ELSE
  IF (LELAM) THEN
    CALL EDIST_GRID (KFDISTG=2_JPIM, KFROM=[1_JPIM, 1_JPIM], PGP=ZGPUV (:,1,1:2,:))
  ELSE
    CALL DIST_GRID (KFDISTG=2_JPIM, KFROM=[1_JPIM, 1_JPIM], PGP=ZGPUV (:,1,1:2,:))
  ENDIF
ENDIF

DO IFLD = 2, IFLDGPG
  ZGPUV (:, IFLD, 1, 1) = ZGPUV (:, 1, 1, 1) * IFLD
  ZGPUV (:, IFLD, 2, 1) = ZGPUV (:, 1, 2, 1) * IFLD
ENDDO

END SUBROUTINE

END PROGRAM TEST

